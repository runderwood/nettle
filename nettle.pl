#!/usr/bin/perl

package nettle;

use strict;
use warnings;

use File::Spec::Functions qw(rel2abs);
use File::Basename;
use File::Find;
use File::Path;
use File::stat;
use Data::Dumper;

my @fileextensions = ('nettle');

my $global_title = 'Wonders never cease.';
my $global_bin_dir = dirname(rel2abs($0));
my $global_items_dir = $global_bin_dir.'/items';
my $global_out_dir = $global_bin_dir.'/out';

if($ARGV[0]) {
    $global_items_dir = $ARGV[0];
}

if($ARGV[1]) {
    $global_out_dir = $ARGV[1];
}

my $default_suit = 'txt';
my $default_mode = '';
my $default_type = 'body';
my $default_items_dir = $global_bin_dir.'/items';

my $html_base_href;# = 'http://whereismybon.net';
my $html_css_uri = 'css/base.css';

sub find_files {
    my $top_dir = shift;
    my @exts;
    while(my $ext = shift) {
        push @exts, $ext;
    }
    my @found;
    find(
        sub {
            for my $xt (@exts) {
                if(substr($_, -(length($xt)+1)) eq ".$xt") {
                    push @found, $File::Find::name;
                    return;
                }
            }
        },
        ($top_dir)
    );
    return @found;
}

sub parse {
    my $dir = shift;
    my $path = shift;
    open INFILE, "<$path";
    my %hdrs;
    while(<INFILE>) {
        chomp;
        last if $_ eq "" || index($_, ':') == -1;
        my $delim = index($_, ':');
        my $k = lc(substr($_, 0, $delim));
        my $v = substr($_, $delim+1);
        $v =~ s/(^\s+)|(\s+$)//;
        $hdrs{$k} = $v;
    }
    my $body;
    while(<INFILE>) {
        $body .= $_;
    }
    $hdrs{'body'} = $body;
    $hdrs{'dir'} = $dir;
    $hdrs{'path'} = $path;
    $hdrs{'uri'} = $path;
    $hdrs{'uri'} =~ s/^(.+)\.[a-z]+$/$1/;
    my $dir_ = $dir;
    $dir_ =~ s/\//\\\//g;
    $hdrs{'uri'} =~ s/^$dir_//;
    $hdrs{'uridir'} = $hdrs{'uri'};
    $hdrs{'uridir'} =~ s/^(.+\/)[^\/]+$/$1/;
    $hdrs{'urifile'} = $hdrs{'uri'};
    $hdrs{'urifile'} =~ s/^(.+\/)?([^\/]+)$/$2/;
    $hdrs{'urifile'} = $hdrs{'uri'} if !$hdrs{'urifile'};
    my $fstat = stat("$path");
    my $mtime = scalar localtime($fstat->mtime);
    $hdrs{'mtime'} = $mtime;
    $hdrs{'mtimeraw'} = $fstat->mtime;
    return \%hdrs;
}

### formatting (suits)

sub f_txt_head {
    return "#HEAD\n\n\n";
}
sub f_txt_body {
    my $parts = shift;
    return "##".$parts->{'title'}."\n".$parts->{'mtime'}."\n\n".$parts->{'body'}."\n";
}
sub f_txt_body_teaser {
    my $parts = shift;
    return "...teaser!...\n";
}
sub f_txt_newsitem {}
sub f_txt_newsitem_teaser {}
sub f_txt_foot {
    return "\n---\ngenerated by [nettle](http://gearslips.net/nettle).\n";
}

sub f_html_head {
    my $title = shift;
    my $basehtml = '';
    $basehtml = '<base href="'.$html_base_href.'"/>' if $html_base_href;
    my $csshtml = '';
    $csshtml = '<link rel="stylesheet" type="text/css" href="'.$html_css_uri.'" />'
        if $html_css_uri;
    return "<html><head>$basehtml".
        "<title>".($title ? $title : '.:|nettle|:.')."</title>".
        $csshtml.
        "</head><body>\n"; 
}
sub f_html_body {
    my $parts = shift;
    my $body = $parts->{'body'};
    $body = txt2html($body);
    return "<h2>".$parts->{'title'}."</h2><h3>".
        $parts->{'mtime'}."</h3>\n\n<div class=\"item\">".
        $body."</div>\n";
}
sub f_html_body_teaser {
    my $parts = shift;
    my $cat = $parts->{'uridir'};
    $cat =~ s/\/$//;
    #$cat =~ s/(.+)\/.+$/$1/;
    if($cat eq $parts->{'uri'}) {
        $cat = 'global';
    }
    return "<h2><a href=\"".$parts->{'uri'}.".html\">".$parts->{'title'}."</a></h2>\n".
        "<h3> [ $cat ] - ".$parts->{'mtime'}."</h3>\n";
}
sub f_html_foot {
    return "</body></html>";
}

sub nettlefy {
    my $items = shift;
    my $suit = shift;
    my $mode = shift;
    my $title = shift;
    my $do_not_wrap = shift;
    $suit = $default_suit if !$suit;
    $mode = $default_mode if !$mode;
    my $fxn_pre = "f_".$suit."_";
    my $fin;
    $fin .= &{\&{$fxn_pre."head"}}($title) unless $do_not_wrap;
    if(ref $items eq 'ARRAY') {
        for my $parts (@$items) {
            my $type = $parts->{'type'};
            $type = $default_type if !$type;
            $fin .= &{\&{$fxn_pre.$type.($mode ? "_$mode" : '')}}($parts);
        }
    } else {
        my $type = $items->{'type'};
        $type = $default_type if !$type;
        $fin .= &{\&{$fxn_pre.$type.($mode ? "_$mode" : '')}}($items);
    }
    $fin .= &{\&{$fxn_pre."foot"}}() unless $do_not_wrap;
    return $fin;
}

sub txt2html {
    my $str = shift;
    $str =~ s/\[([^\]]+)\]\(([^\)]+)\)/<a href="$2">$1<\/a>/g;
    $str =~ s/(.+)\n{2,}/$1<\/p><p>\n/g;
    $str = "<p>$str</p>";
    return $str;
}

my $basedir = -d $global_items_dir ? 
    $global_items_dir : 
    (-d $default_items_dir ? 
        $default_items_dir : 
        "."
    );
my @found = find_files($basedir, 'txt', 'nettle');
my @items;
for my $fnd (@found) {
    push @items, parse($basedir, $fnd);
}
my $outdir = $global_out_dir;
if(!(-d $outdir)) {
    mkpath($outdir) or die('Could not stat output dir.');
}
open IDX, ">$outdir/index.html";
print IDX nettlefy(\@items, 'html', 'teaser', $global_title);
close IDX;
for my $n (@items) {
    if(!(-d $outdir.$n->{'uridir'})) {
        mkpath($outdir.$n->{'uridir'});
    }
    my $path = $outdir.$n->{'uri'}.'.html';
    open ITEM, ">$path";
    print ITEM nettlefy($n, 'html', '', "$global_title - ".$n->{'title'});
}
